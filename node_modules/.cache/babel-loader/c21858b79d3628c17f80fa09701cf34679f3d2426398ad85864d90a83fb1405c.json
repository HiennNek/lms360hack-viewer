{"ast":null,"code":"import { openDB } from \"idb\";\nimport JSZip from \"jszip\";\nconst DB_NAME = \"h5p-storage\";\nconst STORE_NAME = \"files\";\nasync function getDB() {\n  return openDB(DB_NAME, 1, {\n    upgrade(db) {\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        db.createObjectStore(STORE_NAME);\n      }\n    }\n  });\n}\n\n// Helper to find the common prefix or root folder if h5p.json is nested\n// If h5p.json is at \"my-content/h5p.json\", we treat \"my-content/\" as the root.\nfunction findRootPath(files) {\n  const h5pFile = files.find(f => f.path.endsWith(\"h5p.json\") && (f.path.indexOf(\"/\") === -1 || f.path.split(\"/\").length === 2));\n  // Wait, standard H5P zip often has h5p.json at root.\n  // But simply: Find `h5p.json`.\n  // If multiple h5p.json (unlikely), pick the shallowest one?\n\n  const h5pEntry = files.find(f => f.path.endsWith(\"h5p.json\"));\n  if (!h5pEntry) return \"\"; // Should error out?\n\n  // \"folder/h5p.json\" -> root is \"folder/\"\n  // \"h5p.json\" -> root is \"\"\n  const path = h5pEntry.path;\n  const lastSlash = path.lastIndexOf(\"/\");\n  if (lastSlash === -1) return \"\";\n  return path.substring(0, lastSlash + 1);\n}\nexport async function saveH5P(file) {\n  const db = await getDB();\n  const zip = new JSZip();\n  const zipContent = await zip.loadAsync(file);\n\n  // 1. Extract all blobs first to avoid transaction inactivity\n  const files = [];\n  const extractionPromises = [];\n  zipContent.forEach((relativePath, zipEntry) => {\n    if (!zipEntry.dir) {\n      extractionPromises.push(zipEntry.async(\"blob\").then(blob => {\n        files.push({\n          path: relativePath,\n          blob\n        });\n      }));\n    }\n  });\n  await Promise.all(extractionPromises);\n\n  // Determine root prefix\n  const rootPrefix = findRootPath(files);\n\n  // 2. Clear old data and store new files\n  const tx = db.transaction(STORE_NAME, \"readwrite\");\n  const store = tx.objectStore(STORE_NAME);\n  await store.clear();\n  const id = \"content-\" + Date.now();\n  for (const {\n    path,\n    blob\n  } of files) {\n    let storagePath = path;\n    if (rootPrefix && path.startsWith(rootPrefix)) {\n      storagePath = path.substring(rootPrefix.length);\n    }\n    console.log(\"[H5P Storage] Saving: \".concat(storagePath, \" (Size: \").concat(blob.size, \")\"));\n    store.put(blob, storagePath);\n  }\n  await tx.done;\n  return id;\n}","map":{"version":3,"names":["openDB","JSZip","DB_NAME","STORE_NAME","getDB","upgrade","db","objectStoreNames","contains","createObjectStore","findRootPath","files","h5pFile","find","f","path","endsWith","indexOf","split","length","h5pEntry","lastSlash","lastIndexOf","substring","saveH5P","file","zip","zipContent","loadAsync","extractionPromises","forEach","relativePath","zipEntry","dir","push","async","then","blob","Promise","all","rootPrefix","tx","transaction","store","objectStore","clear","id","Date","now","storagePath","startsWith","console","log","concat","size","put","done"],"sources":["/home/hien/lms360hack-viewer/src/services/h5p-storage.js"],"sourcesContent":["import { openDB } from \"idb\";\nimport JSZip from \"jszip\";\n\nconst DB_NAME = \"h5p-storage\";\nconst STORE_NAME = \"files\";\n\nasync function getDB() {\n    return openDB(DB_NAME, 1, {\n        upgrade(db) {\n            if (!db.objectStoreNames.contains(STORE_NAME)) {\n                db.createObjectStore(STORE_NAME);\n            }\n        },\n    });\n}\n\n// Helper to find the common prefix or root folder if h5p.json is nested\n// If h5p.json is at \"my-content/h5p.json\", we treat \"my-content/\" as the root.\nfunction findRootPath(files) {\n    const h5pFile = files.find(f => f.path.endsWith(\"h5p.json\") && (f.path.indexOf(\"/\") === -1 || f.path.split(\"/\").length === 2));\n    // Wait, standard H5P zip often has h5p.json at root.\n    // But simply: Find `h5p.json`.\n    // If multiple h5p.json (unlikely), pick the shallowest one?\n\n    const h5pEntry = files.find(f => f.path.endsWith(\"h5p.json\"));\n    if (!h5pEntry) return \"\"; // Should error out?\n\n    // \"folder/h5p.json\" -> root is \"folder/\"\n    // \"h5p.json\" -> root is \"\"\n    const path = h5pEntry.path;\n    const lastSlash = path.lastIndexOf(\"/\");\n    if (lastSlash === -1) return \"\";\n    return path.substring(0, lastSlash + 1);\n}\n\nexport async function saveH5P(file) {\n    const db = await getDB();\n    const zip = new JSZip();\n    const zipContent = await zip.loadAsync(file);\n\n    // 1. Extract all blobs first to avoid transaction inactivity\n    const files = [];\n    const extractionPromises = [];\n\n    zipContent.forEach((relativePath, zipEntry) => {\n        if (!zipEntry.dir) {\n            extractionPromises.push(\n                zipEntry.async(\"blob\").then((blob) => {\n                    files.push({ path: relativePath, blob });\n                })\n            );\n        }\n    });\n\n    await Promise.all(extractionPromises);\n\n    // Determine root prefix\n    const rootPrefix = findRootPath(files);\n\n    // 2. Clear old data and store new files\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(STORE_NAME);\n\n    await store.clear();\n\n    const id = \"content-\" + Date.now();\n\n    for (const { path, blob } of files) {\n        let storagePath = path;\n        if (rootPrefix && path.startsWith(rootPrefix)) {\n            storagePath = path.substring(rootPrefix.length);\n        }\n\n        console.log(`[H5P Storage] Saving: ${storagePath} (Size: ${blob.size})`);\n        store.put(blob, storagePath);\n    }\n\n    await tx.done;\n\n    return id;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}