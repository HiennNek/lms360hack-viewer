{"ast":null,"code":"import { openDB } from \"idb\";\nimport JSZip from \"jszip\";\nconst DB_NAME = \"h5p-storage\";\nconst STORE_NAME = \"files\";\nasync function getDB() {\n  return openDB(DB_NAME, 1, {\n    upgrade(db) {\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        db.createObjectStore(STORE_NAME);\n      }\n    }\n  });\n}\nexport async function saveH5P(file) {\n  const db = await getDB();\n  const zip = new JSZip();\n  const zipContent = await zip.loadAsync(file);\n  const tx = db.transaction(STORE_NAME, \"readwrite\");\n  const store = tx.objectStore(STORE_NAME);\n\n  // Clear existing files to avoid conflicts/leftovers (optional, but good for single-player demo)\n  await store.clear();\n  const id = \"content-\" + Date.now(); // Unique ID for this upload session (or just use a fixed one if we clear)\n\n  const promises = [];\n  zipContent.forEach((relativePath, zipEntry) => {\n    if (!zipEntry.dir) {\n      const promise = zipEntry.async(\"blob\").then(blob => {\n        // We store files with the ID as prefix to simulate a folder structure\n        // But for the Service Worker to find it easily from a clean URL, we might just want to use the relative path\n        // IF we assume only one H5P is active at a time. \n        // Let's implement single-active-H5P logic for simplicity first.\n        return store.put(blob, relativePath);\n      });\n      promises.push(promise);\n    }\n  });\n  await Promise.all(promises);\n  await tx.done;\n  return id;\n}","map":{"version":3,"names":["openDB","JSZip","DB_NAME","STORE_NAME","getDB","upgrade","db","objectStoreNames","contains","createObjectStore","saveH5P","file","zip","zipContent","loadAsync","tx","transaction","store","objectStore","clear","id","Date","now","promises","forEach","relativePath","zipEntry","dir","promise","async","then","blob","put","push","Promise","all","done"],"sources":["/home/hien/Downloads/h5p-standalone-in-react-1-forked/src/services/h5p-storage.js"],"sourcesContent":["import { openDB } from \"idb\";\nimport JSZip from \"jszip\";\n\nconst DB_NAME = \"h5p-storage\";\nconst STORE_NAME = \"files\";\n\nasync function getDB() {\n    return openDB(DB_NAME, 1, {\n        upgrade(db) {\n            if (!db.objectStoreNames.contains(STORE_NAME)) {\n                db.createObjectStore(STORE_NAME);\n            }\n        },\n    });\n}\n\nexport async function saveH5P(file) {\n    const db = await getDB();\n    const zip = new JSZip();\n    const zipContent = await zip.loadAsync(file);\n\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(STORE_NAME);\n\n    // Clear existing files to avoid conflicts/leftovers (optional, but good for single-player demo)\n    await store.clear();\n\n    const id = \"content-\" + Date.now(); // Unique ID for this upload session (or just use a fixed one if we clear)\n\n    const promises = [];\n\n    zipContent.forEach((relativePath, zipEntry) => {\n        if (!zipEntry.dir) {\n            const promise = zipEntry.async(\"blob\").then((blob) => {\n                // We store files with the ID as prefix to simulate a folder structure\n                // But for the Service Worker to find it easily from a clean URL, we might just want to use the relative path\n                // IF we assume only one H5P is active at a time. \n                // Let's implement single-active-H5P logic for simplicity first.\n                return store.put(blob, relativePath);\n            });\n            promises.push(promise);\n        }\n    });\n\n    await Promise.all(promises);\n    await tx.done;\n\n    return id;\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,KAAK;AAC5B,OAAOC,KAAK,MAAM,OAAO;AAEzB,MAAMC,OAAO,GAAG,aAAa;AAC7B,MAAMC,UAAU,GAAG,OAAO;AAE1B,eAAeC,KAAKA,CAAA,EAAG;EACnB,OAAOJ,MAAM,CAACE,OAAO,EAAE,CAAC,EAAE;IACtBG,OAAOA,CAACC,EAAE,EAAE;MACR,IAAI,CAACA,EAAE,CAACC,gBAAgB,CAACC,QAAQ,CAACL,UAAU,CAAC,EAAE;QAC3CG,EAAE,CAACG,iBAAiB,CAACN,UAAU,CAAC;MACpC;IACJ;EACJ,CAAC,CAAC;AACN;AAEA,OAAO,eAAeO,OAAOA,CAACC,IAAI,EAAE;EAChC,MAAML,EAAE,GAAG,MAAMF,KAAK,CAAC,CAAC;EACxB,MAAMQ,GAAG,GAAG,IAAIX,KAAK,CAAC,CAAC;EACvB,MAAMY,UAAU,GAAG,MAAMD,GAAG,CAACE,SAAS,CAACH,IAAI,CAAC;EAE5C,MAAMI,EAAE,GAAGT,EAAE,CAACU,WAAW,CAACb,UAAU,EAAE,WAAW,CAAC;EAClD,MAAMc,KAAK,GAAGF,EAAE,CAACG,WAAW,CAACf,UAAU,CAAC;;EAExC;EACA,MAAMc,KAAK,CAACE,KAAK,CAAC,CAAC;EAEnB,MAAMC,EAAE,GAAG,UAAU,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC;;EAEpC,MAAMC,QAAQ,GAAG,EAAE;EAEnBV,UAAU,CAACW,OAAO,CAAC,CAACC,YAAY,EAAEC,QAAQ,KAAK;IAC3C,IAAI,CAACA,QAAQ,CAACC,GAAG,EAAE;MACf,MAAMC,OAAO,GAAGF,QAAQ,CAACG,KAAK,CAAC,MAAM,CAAC,CAACC,IAAI,CAAEC,IAAI,IAAK;QAClD;QACA;QACA;QACA;QACA,OAAOd,KAAK,CAACe,GAAG,CAACD,IAAI,EAAEN,YAAY,CAAC;MACxC,CAAC,CAAC;MACFF,QAAQ,CAACU,IAAI,CAACL,OAAO,CAAC;IAC1B;EACJ,CAAC,CAAC;EAEF,MAAMM,OAAO,CAACC,GAAG,CAACZ,QAAQ,CAAC;EAC3B,MAAMR,EAAE,CAACqB,IAAI;EAEb,OAAOhB,EAAE;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}