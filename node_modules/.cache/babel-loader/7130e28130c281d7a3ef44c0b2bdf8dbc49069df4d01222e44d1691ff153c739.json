{"ast":null,"code":"import{openDB}from\"idb\";import JSZip from\"jszip\";const DB_NAME=\"h5p-storage\";const STORE_NAME=\"files\";async function getDB(){return openDB(DB_NAME,1,{upgrade(db){if(!db.objectStoreNames.contains(STORE_NAME)){db.createObjectStore(STORE_NAME);}}});}// Helper to find the common prefix or root folder if h5p.json is nested\n// If h5p.json is at \"my-content/h5p.json\", we treat \"my-content/\" as the root.\nfunction findRootPath(files){const h5pFile=files.find(f=>f.path.endsWith(\"h5p.json\")&&(f.path.indexOf(\"/\")===-1||f.path.split(\"/\").length===2));// Wait, standard H5P zip often has h5p.json at root.\n// But simply: Find `h5p.json`.\n// If multiple h5p.json (unlikely), pick the shallowest one?\nconst h5pEntry=files.find(f=>f.path.endsWith(\"h5p.json\"));if(!h5pEntry)return\"\";// Should error out?\n// \"folder/h5p.json\" -> root is \"folder/\"\n// \"h5p.json\" -> root is \"\"\nconst path=h5pEntry.path;const lastSlash=path.lastIndexOf(\"/\");if(lastSlash===-1)return\"\";return path.substring(0,lastSlash+1);}export async function saveH5P(file){const db=await getDB();const zip=new JSZip();const zipContent=await zip.loadAsync(file);// 1. Extract all blobs first to avoid transaction inactivity\nconst files=[];const extractionPromises=[];zipContent.forEach((relativePath,zipEntry)=>{if(!zipEntry.dir){extractionPromises.push(zipEntry.async(\"blob\").then(blob=>{files.push({path:relativePath,blob});}));}});await Promise.all(extractionPromises);// Determine root prefix\nconst rootPrefix=findRootPath(files);// 2. Clear old data and store new files\nconst tx=db.transaction(STORE_NAME,\"readwrite\");const store=tx.objectStore(STORE_NAME);await store.clear();const id=\"content-\"+Date.now();for(const{path,blob}of files){let storagePath=path;if(rootPrefix&&path.startsWith(rootPrefix)){storagePath=path.substring(rootPrefix.length);}console.log(\"[H5P Storage] Saving: \".concat(storagePath,\" (Size: \").concat(blob.size,\")\"));store.put(blob,storagePath);}await tx.done;return id;}","map":{"version":3,"names":["openDB","JSZip","DB_NAME","STORE_NAME","getDB","upgrade","db","objectStoreNames","contains","createObjectStore","findRootPath","files","h5pFile","find","f","path","endsWith","indexOf","split","length","h5pEntry","lastSlash","lastIndexOf","substring","saveH5P","file","zip","zipContent","loadAsync","extractionPromises","forEach","relativePath","zipEntry","dir","push","async","then","blob","Promise","all","rootPrefix","tx","transaction","store","objectStore","clear","id","Date","now","storagePath","startsWith","console","log","concat","size","put","done"],"sources":["/home/hien/Downloads/h5p-standalone-in-react-1-forked/src/services/h5p-storage.js"],"sourcesContent":["import { openDB } from \"idb\";\nimport JSZip from \"jszip\";\n\nconst DB_NAME = \"h5p-storage\";\nconst STORE_NAME = \"files\";\n\nasync function getDB() {\n    return openDB(DB_NAME, 1, {\n        upgrade(db) {\n            if (!db.objectStoreNames.contains(STORE_NAME)) {\n                db.createObjectStore(STORE_NAME);\n            }\n        },\n    });\n}\n\n// Helper to find the common prefix or root folder if h5p.json is nested\n// If h5p.json is at \"my-content/h5p.json\", we treat \"my-content/\" as the root.\nfunction findRootPath(files) {\n    const h5pFile = files.find(f => f.path.endsWith(\"h5p.json\") && (f.path.indexOf(\"/\") === -1 || f.path.split(\"/\").length === 2));\n    // Wait, standard H5P zip often has h5p.json at root.\n    // But simply: Find `h5p.json`.\n    // If multiple h5p.json (unlikely), pick the shallowest one?\n\n    const h5pEntry = files.find(f => f.path.endsWith(\"h5p.json\"));\n    if (!h5pEntry) return \"\"; // Should error out?\n\n    // \"folder/h5p.json\" -> root is \"folder/\"\n    // \"h5p.json\" -> root is \"\"\n    const path = h5pEntry.path;\n    const lastSlash = path.lastIndexOf(\"/\");\n    if (lastSlash === -1) return \"\";\n    return path.substring(0, lastSlash + 1);\n}\n\nexport async function saveH5P(file) {\n    const db = await getDB();\n    const zip = new JSZip();\n    const zipContent = await zip.loadAsync(file);\n\n    // 1. Extract all blobs first to avoid transaction inactivity\n    const files = [];\n    const extractionPromises = [];\n\n    zipContent.forEach((relativePath, zipEntry) => {\n        if (!zipEntry.dir) {\n            extractionPromises.push(\n                zipEntry.async(\"blob\").then((blob) => {\n                    files.push({ path: relativePath, blob });\n                })\n            );\n        }\n    });\n\n    await Promise.all(extractionPromises);\n\n    // Determine root prefix\n    const rootPrefix = findRootPath(files);\n\n    // 2. Clear old data and store new files\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(STORE_NAME);\n\n    await store.clear();\n\n    const id = \"content-\" + Date.now();\n\n    for (const { path, blob } of files) {\n        let storagePath = path;\n        if (rootPrefix && path.startsWith(rootPrefix)) {\n            storagePath = path.substring(rootPrefix.length);\n        }\n\n        console.log(`[H5P Storage] Saving: ${storagePath} (Size: ${blob.size})`);\n        store.put(blob, storagePath);\n    }\n\n    await tx.done;\n\n    return id;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}