{"ast":null,"code":"import{openDB}from\"idb\";import JSZip from\"jszip\";const DB_NAME=\"h5p-storage\";const STORE_NAME=\"files\";async function getDB(){return openDB(DB_NAME,1,{upgrade(db){if(!db.objectStoreNames.contains(STORE_NAME)){db.createObjectStore(STORE_NAME);}}});}export async function saveH5P(file){const db=await getDB();const zip=new JSZip();const zipContent=await zip.loadAsync(file);const tx=db.transaction(STORE_NAME,\"readwrite\");const store=tx.objectStore(STORE_NAME);// Clear existing files to avoid conflicts/leftovers (optional, but good for single-player demo)\nawait store.clear();const id=\"content-\"+Date.now();// Unique ID for this upload session (or just use a fixed one if we clear)\nconst promises=[];zipContent.forEach((relativePath,zipEntry)=>{if(!zipEntry.dir){const promise=zipEntry.async(\"blob\").then(blob=>{// We store files with the ID as prefix to simulate a folder structure\n// But for the Service Worker to find it easily from a clean URL, we might just want to use the relative path\n// IF we assume only one H5P is active at a time. \n// Let's implement single-active-H5P logic for simplicity first.\nreturn store.put(blob,relativePath);});promises.push(promise);}});await Promise.all(promises);await tx.done;return id;}","map":{"version":3,"names":["openDB","JSZip","DB_NAME","STORE_NAME","getDB","upgrade","db","objectStoreNames","contains","createObjectStore","saveH5P","file","zip","zipContent","loadAsync","tx","transaction","store","objectStore","clear","id","Date","now","promises","forEach","relativePath","zipEntry","dir","promise","async","then","blob","put","push","Promise","all","done"],"sources":["/home/hien/Downloads/h5p-standalone-in-react-1-forked/src/services/h5p-storage.js"],"sourcesContent":["import { openDB } from \"idb\";\nimport JSZip from \"jszip\";\n\nconst DB_NAME = \"h5p-storage\";\nconst STORE_NAME = \"files\";\n\nasync function getDB() {\n    return openDB(DB_NAME, 1, {\n        upgrade(db) {\n            if (!db.objectStoreNames.contains(STORE_NAME)) {\n                db.createObjectStore(STORE_NAME);\n            }\n        },\n    });\n}\n\nexport async function saveH5P(file) {\n    const db = await getDB();\n    const zip = new JSZip();\n    const zipContent = await zip.loadAsync(file);\n\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(STORE_NAME);\n\n    // Clear existing files to avoid conflicts/leftovers (optional, but good for single-player demo)\n    await store.clear();\n\n    const id = \"content-\" + Date.now(); // Unique ID for this upload session (or just use a fixed one if we clear)\n\n    const promises = [];\n\n    zipContent.forEach((relativePath, zipEntry) => {\n        if (!zipEntry.dir) {\n            const promise = zipEntry.async(\"blob\").then((blob) => {\n                // We store files with the ID as prefix to simulate a folder structure\n                // But for the Service Worker to find it easily from a clean URL, we might just want to use the relative path\n                // IF we assume only one H5P is active at a time. \n                // Let's implement single-active-H5P logic for simplicity first.\n                return store.put(blob, relativePath);\n            });\n            promises.push(promise);\n        }\n    });\n\n    await Promise.all(promises);\n    await tx.done;\n\n    return id;\n}\n"],"mappings":"AAAA,OAASA,MAAM,KAAQ,KAAK,CAC5B,MAAO,CAAAC,KAAK,KAAM,OAAO,CAEzB,KAAM,CAAAC,OAAO,CAAG,aAAa,CAC7B,KAAM,CAAAC,UAAU,CAAG,OAAO,CAE1B,cAAe,CAAAC,KAAKA,CAAA,CAAG,CACnB,MAAO,CAAAJ,MAAM,CAACE,OAAO,CAAE,CAAC,CAAE,CACtBG,OAAOA,CAACC,EAAE,CAAE,CACR,GAAI,CAACA,EAAE,CAACC,gBAAgB,CAACC,QAAQ,CAACL,UAAU,CAAC,CAAE,CAC3CG,EAAE,CAACG,iBAAiB,CAACN,UAAU,CAAC,CACpC,CACJ,CACJ,CAAC,CAAC,CACN,CAEA,MAAO,eAAe,CAAAO,OAAOA,CAACC,IAAI,CAAE,CAChC,KAAM,CAAAL,EAAE,CAAG,KAAM,CAAAF,KAAK,CAAC,CAAC,CACxB,KAAM,CAAAQ,GAAG,CAAG,GAAI,CAAAX,KAAK,CAAC,CAAC,CACvB,KAAM,CAAAY,UAAU,CAAG,KAAM,CAAAD,GAAG,CAACE,SAAS,CAACH,IAAI,CAAC,CAE5C,KAAM,CAAAI,EAAE,CAAGT,EAAE,CAACU,WAAW,CAACb,UAAU,CAAE,WAAW,CAAC,CAClD,KAAM,CAAAc,KAAK,CAAGF,EAAE,CAACG,WAAW,CAACf,UAAU,CAAC,CAExC;AACA,KAAM,CAAAc,KAAK,CAACE,KAAK,CAAC,CAAC,CAEnB,KAAM,CAAAC,EAAE,CAAG,UAAU,CAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAE;AAEpC,KAAM,CAAAC,QAAQ,CAAG,EAAE,CAEnBV,UAAU,CAACW,OAAO,CAAC,CAACC,YAAY,CAAEC,QAAQ,GAAK,CAC3C,GAAI,CAACA,QAAQ,CAACC,GAAG,CAAE,CACf,KAAM,CAAAC,OAAO,CAAGF,QAAQ,CAACG,KAAK,CAAC,MAAM,CAAC,CAACC,IAAI,CAAEC,IAAI,EAAK,CAClD;AACA;AACA;AACA;AACA,MAAO,CAAAd,KAAK,CAACe,GAAG,CAACD,IAAI,CAAEN,YAAY,CAAC,CACxC,CAAC,CAAC,CACFF,QAAQ,CAACU,IAAI,CAACL,OAAO,CAAC,CAC1B,CACJ,CAAC,CAAC,CAEF,KAAM,CAAAM,OAAO,CAACC,GAAG,CAACZ,QAAQ,CAAC,CAC3B,KAAM,CAAAR,EAAE,CAACqB,IAAI,CAEb,MAAO,CAAAhB,EAAE,CACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}